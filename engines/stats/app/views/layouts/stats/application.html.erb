<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="turbo-refresh-method" content="morph">
  <title><%= Stats.dashboard_title %></title>
  <%= csrf_meta_tags %>
  <%= action_cable_meta_tag %>

  <!-- Mona Sans Font from Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Mona+Sans:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>

  <style>
    :root {
      --bg-primary: #0c0c0c;
      --bg-card: #141414;
      --bg-elevated: #1a1a1a;
      --border: #262626;
      --border-subtle: #1f1f1f;
      --text-primary: #fafafa;
      --text-secondary: #a3a3a3;
      --text-muted: #525252;
      --accent: #a855f7;
    }

    *, *::before, *::after {
      font-family: 'Mona Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif !important;
    }

    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Mona Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    }

    code, pre, .font-mono {
      font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace !important;
    }

    .card {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: 16px;
    }

    [data-updating="true"] {
      background: rgba(34, 197, 94, 0.08) !important;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 600;
      letter-spacing: -0.025em;
      line-height: 1.1;
    }

    .stat-label {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .table-row:hover {
      background: var(--bg-elevated);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.625rem;
      border-radius: 100px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .pill-purple { background: rgba(168, 85, 247, 0.12); color: #c084fc; }
    .pill-green { background: rgba(34, 197, 94, 0.12); color: #4ade80; }
    .pill-neutral { background: rgba(163, 163, 163, 0.12); color: #a3a3a3; }

    .btn {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-weight: 500;
      font-size: 0.875rem;
      transition: opacity 0.15s;
    }

    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text-secondary);
    }

    .btn-secondary:hover:not(:disabled) {
      opacity: 0.8;
    }

    .select-modern {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.375rem 0.75rem;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .select-modern:focus {
      outline: none;
      border-color: var(--accent);
    }

    .container-padding {
      width: 100%;
      max-width: 80rem;
      margin-left: auto;
      margin-right: auto;
      padding-left: 1rem;
      padding-right: 1rem;
    }

    @media (min-width: 640px) {
      .container-padding {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }
    }

    @media (min-width: 1024px) {
      .container-padding {
        padding-left: 2rem;
        padding-right: 2rem;
      }
    }

    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  </style>
</head>
<body class="min-h-screen antialiased">
  <nav class="border-b border-[#1f1f1f] py-5">
    <div class="container-padding flex justify-between items-center">
      <div class="flex items-center gap-4">
        <div class="w-9 h-9 rounded-xl bg-[#a855f7] flex items-center justify-center">
          <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 24 24">
            <path d="M13 10V3L4 14h7v7l9-11h-7z"/>
          </svg>
        </div>
        <span class="text-lg font-semibold tracking-tight"><%= Stats.dashboard_title %></span>
      </div>
      <div class="flex items-center gap-8">
        <div id="connection-status" class="flex items-center gap-2.5">
          <span id="status-dot" class="w-2 h-2 rounded-full bg-amber-500 animate-pulse"></span>
          <span id="status-text" class="text-sm text-[#737373]">Connecting</span>
        </div>
        <% if Stats.authentication_enabled? && current_api_key %>
          <%= link_to logout_path, data: { turbo_method: :delete }, class: "text-sm text-[#737373] hover:text-white transition-colors" do %>
            Sign out
          <% end %>
        <% end %>
      </div>
    </div>
  </nav>

  <main class="container-padding py-10">
    <% if flash[:alert] %>
      <div class="card mb-8 px-5 py-4 border-l-4 border-l-red-500">
        <span class="text-red-400 text-sm"><%= flash[:alert] %></span>
      </div>
    <% end %>
    <% if flash[:notice] %>
      <div class="card mb-8 px-5 py-4 border-l-4 border-l-green-500">
        <span class="text-green-400 text-sm"><%= flash[:notice] %></span>
      </div>
    <% end %>

    <%= yield %>
  </main>

  <script>
    (function() {
      const statusDot = document.getElementById('status-dot')
      const statusText = document.getElementById('status-text')

      function setConnected() {
        if (statusDot) statusDot.className = 'w-2 h-2 rounded-full bg-emerald-500'
        if (statusText) {
          statusText.textContent = 'Live'
          statusText.className = 'text-sm text-emerald-500 font-medium'
        }
      }

      function setDisconnected() {
        if (statusDot) statusDot.className = 'w-2 h-2 rounded-full bg-red-500'
        if (statusText) {
          statusText.textContent = 'Offline'
          statusText.className = 'text-sm text-red-500'
        }
      }

      function updateElement(id, value) {
        const el = document.getElementById(id)
        if (el) {
          el.setAttribute('data-updating', 'true')
          el.textContent = value
          setTimeout(() => el.removeAttribute('data-updating'), 300)
        }
      }

      function formatNumber(num) {
        if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M'
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K'
        return new Intl.NumberFormat().format(num)
      }

      function formatDuration(seconds) {
        const days = Math.floor(seconds / 86400)
        const hours = Math.floor((seconds % 86400) / 3600)
        const mins = Math.floor((seconds % 3600) / 60)
        if (days > 0) return `${days}d ${hours}h`
        if (hours > 0) return `${hours}h ${mins}m`
        return `${mins}m`
      }

      function formatTimeAgo(isoString) {
        const date = new Date(isoString)
        const seconds = Math.floor((new Date() - date) / 1000)
        if (seconds < 60) return 'now'
        const mins = Math.floor(seconds / 60)
        if (mins < 60) return `${mins}m`
        const hours = Math.floor(mins / 60)
        if (hours < 24) return `${hours}h`
        return `${Math.floor(hours / 24)}d`
      }

      // Escape HTML to prevent XSS attacks
      function escapeHtml(str) {
        if (str === null || str === undefined) return ''
        const div = document.createElement('div')
        div.textContent = str
        return div.innerHTML
      }

      let allConnections = []
      let currentPage = 1
      let perPage = 10

      function updateConnectionsTable(connections) {
        allConnections = connections
        renderConnectionsPage()
      }

      function renderConnectionsPage() {
        const tbody = document.getElementById('connections-tbody')
        if (!tbody) return

        const total = allConnections.length
        const totalPages = Math.ceil(total / perPage)
        currentPage = Math.min(currentPage, Math.max(1, totalPages))

        const start = (currentPage - 1) * perPage
        const end = Math.min(start + perPage, total)
        const pageConnections = allConnections.slice(start, end)

        const totalEl = document.getElementById('connections-total')
        if (totalEl) totalEl.textContent = total

        if (total === 0) {
          tbody.innerHTML = `
            <tr>
              <td colspan="5" class="py-16 text-center text-[#525252]">No active connections</td>
            </tr>
          `
          updatePaginationControls(0, 0, 0)
          return
        }

        tbody.innerHTML = pageConnections.map(conn => `
          <tr class="table-row border-t border-[#1f1f1f]">
            <td class="py-4 font-mono text-sm text-[#a3a3a3]">${escapeHtml(conn.id?.substring(0, 12) || '')}</td>
            <td class="py-4 text-[#a3a3a3]">${escapeHtml(conn.ip_address) || 'â€”'}</td>
            <td class="py-4">
              <span class="pill ${conn.authenticated_pubkeys?.length > 0 ? 'pill-green' : 'pill-neutral'}">${conn.authenticated_pubkeys?.length > 0 ? conn.authenticated_pubkeys.length + ' pubkey' + (conn.authenticated_pubkeys.length > 1 ? 's' : '') : 'Anonymous'}</span>
            </td>
            <td class="py-4">
              <span class="pill pill-purple">${Number(conn.subscription_count) || 0}</span>
            </td>
            <td class="py-4 text-[#525252] text-sm">${formatTimeAgo(conn.connected_at)}</td>
          </tr>
        `).join('')

        updatePaginationControls(start + 1, end, total)
      }

      function updatePaginationControls(start, end, total) {
        const pagination = document.getElementById('connections-pagination')
        const prevBtn = document.getElementById('pagination-prev')
        const nextBtn = document.getElementById('pagination-next')
        const startEl = document.getElementById('pagination-start')
        const endEl = document.getElementById('pagination-end')
        const totalEl = document.getElementById('pagination-total')

        if (!pagination) return
        pagination.classList.toggle('hidden', total <= perPage)

        if (startEl) startEl.textContent = start
        if (endEl) endEl.textContent = end
        if (totalEl) totalEl.textContent = total
        if (prevBtn) prevBtn.disabled = currentPage <= 1
        if (nextBtn) nextBtn.disabled = currentPage >= Math.ceil(total / perPage)
      }

      function setupPaginationListeners() {
        const prevBtn = document.getElementById('pagination-prev')
        const nextBtn = document.getElementById('pagination-next')
        const perPageSelect = document.getElementById('connections-per-page')

        if (prevBtn) {
          prevBtn.addEventListener('click', function() {
            if (currentPage > 1) { currentPage--; renderConnectionsPage() }
          })
        }
        if (nextBtn) {
          nextBtn.addEventListener('click', function() {
            if (currentPage < Math.ceil(allConnections.length / perPage)) { currentPage++; renderConnectionsPage() }
          })
        }
        if (perPageSelect) {
          perPageSelect.addEventListener('change', function(e) {
            perPage = parseInt(e.target.value, 10)
            currentPage = 1
            renderConnectionsPage()
          })
        }
      }

      // Build WebSocket URL properly
      function getWebSocketUrl() {
        const meta = document.querySelector('meta[name="action-cable-url"]')
        if (meta && meta.content) {
          const cableUrl = meta.content
          // If it's already a full URL, convert protocol
          if (cableUrl.startsWith('http')) {
            return cableUrl.replace(/^http/, 'ws')
          }
          // If it's a relative path, build full URL
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
          const host = window.location.host
          return `${protocol}//${host}${cableUrl}`
        }
        // Default fallback
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
        return `${protocol}//${window.location.host}/cable`
      }

      class StatsConnection {
        constructor() {
          this.wsConnected = false
          this.pollInterval = null
          this.connect()
          // Start polling as fallback - runs alongside WebSocket
          this.startPolling()
        }

        connect() {
          const wsUrl = getWebSocketUrl()
          console.log('Connecting to:', wsUrl)

          try {
            this.ws = new WebSocket(wsUrl)

            this.ws.onopen = () => {
              console.log('WebSocket connected')
              this.subscribe()
            }

            this.ws.onmessage = (event) => {
              const data = JSON.parse(event.data)
              if (data.type === 'ping') return
              if (data.type === 'welcome') return
              if (data.type === 'confirm_subscription') {
                console.log('Subscription confirmed')
                this.wsConnected = true
                setConnected()
                return
              }
              if (data.message) this.handleMessage(data.message)
            }

            this.ws.onclose = (event) => {
              console.log('WebSocket closed:', event.code, event.reason)
              this.wsConnected = false
              setDisconnected()
              setTimeout(() => this.connect(), 3000)
            }

            this.ws.onerror = (error) => {
              console.error('WebSocket error:', error)
              this.wsConnected = false
              setDisconnected()
            }
          } catch (error) {
            console.error('Failed to create WebSocket:', error)
            this.wsConnected = false
            setDisconnected()
          }
        }

        subscribe() {
          this.ws.send(JSON.stringify({
            command: 'subscribe',
            identifier: JSON.stringify({ channel: 'Stats::MetricsChannel' })
          }))
        }

        // Polling fallback - fetches from API endpoint
        startPolling() {
          // Poll every 5 seconds as backup
          this.pollInterval = setInterval(() => {
            this.poll()
          }, 5000)
        }

        async poll() {
          try {
            const response = await fetch('<%= api_metrics_path %>')
            if (response.ok) {
              const data = await response.json()
              this.handleMessage(data)
              // If WebSocket isn't connected, show "Polling" status
              if (!this.wsConnected) {
                if (statusDot) statusDot.className = 'w-2 h-2 rounded-full bg-amber-500'
                if (statusText) {
                  statusText.textContent = 'Polling'
                  statusText.className = 'text-sm text-amber-500'
                }
              }
            }
          } catch (error) {
            console.error('Poll error:', error)
          }
        }

        handleMessage(data) {
          if (data.error) {
            console.error('Stats error:', data.error)
            return
          }

          updateElement('stat-connections', formatNumber(data.connections.total))
          updateElement('stat-subscriptions', formatNumber(data.connections.total_subscriptions))
          updateElement('stat-events-total', formatNumber(data.events.total))
          updateElement('stat-events-today', formatNumber(data.events.today))
          updateElement('stat-events-per-min', data.events.per_minute.toFixed(1))
          updateElement('stat-memory', data.system.memory.rss_mb)
          updateElement('stat-memory-panel', data.system.memory.rss_mb)
          updateElement('stat-cpu', data.system.cpu.load_percent)
          updateElement('stat-load-avg', data.system.cpu.load_average)
          updateElement('stat-threads', data.system.process.thread_count)
          updateElement('stat-uptime', formatDuration(data.system.process.uptime_seconds))
          updateElement('stat-db-pool', data.system.database.connections_in_use + '/' + data.system.database.pool_size)

          // Update progress bars
          if (window.updateProgressBars) {
            window.updateProgressBars(
              data.system.cpu.load_percent,
              data.system.memory.rss_mb,
              data.system.database.connections_in_use,
              data.system.database.pool_size
            )
          }

          updateConnectionsTable(data.connections.details)

          const timestamp = new Date(data.collected_at)
          updateElement('last-updated', timestamp.toLocaleTimeString())
        }
      }

      // Initialize when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        setupPaginationListeners()

        // Start WebSocket connection if on dashboard
        if (document.getElementById('stats-dashboard')) {
          new StatsConnection()
        }
      })
    })()
  </script>
</body>
</html>
